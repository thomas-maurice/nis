package nats

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/thomas-maurice/nis/internal/domain/entities"
)

// ServerConfig represents a NATS server configuration
type ServerConfig struct {
	Port                int
	HTTPPort            int
	ClusterName         string
	ClusterPort         int
	Routes              []string
	OperatorJWT         string
	SystemAccountPubKey string
	ResolverPreload     map[string]string // account public key -> JWT
}

// GenerateServerConfig generates a NATS server configuration file
func GenerateServerConfig(cfg ServerConfig) (string, error) {
	const configTemplate = `# NATS Server Configuration
# Generated by NATS Identity Service

# Server listening port
port: {{.Port}}

# HTTP monitoring port
http_port: {{.HTTPPort}}

{{if .ClusterName}}
# Cluster configuration
cluster {
  name: {{.ClusterName}}
  {{if .ClusterPort}}
  port: {{.ClusterPort}}
  {{end}}
  {{if .Routes}}
  routes: [
    {{range .Routes}}
    "{{.}}",
    {{end}}
  ]
  {{end}}
}
{{end}}

# Operator JWT-based authentication
operator: {{.OperatorJWT}}

{{if .SystemAccountPubKey}}
# System account
system_account: {{.SystemAccountPubKey}}
{{end}}

# JWT Resolver configuration
resolver {
  type: full
  # Enable caching of resolved accounts
  allow_delete: true
  {{if .ResolverPreload}}
  # Preload account JWTs
  preload: {
    {{range $key, $value := .ResolverPreload}}
    {{$key}}: {{$value}}
    {{end}}
  }
  {{end}}
}
`

	tmpl, err := template.New("nats-config").Parse(configTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse config template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return "", fmt.Errorf("failed to execute config template: %w", err)
	}

	return buf.String(), nil
}

// GenerateServerConfigForCluster generates NATS server config for a cluster entity
func GenerateServerConfigForCluster(
	cluster *entities.Cluster,
	operator *entities.Operator,
	accounts []*entities.Account,
	port int,
	httpPort int,
) (string, error) {
	// Build resolver preload map
	preload := make(map[string]string)
	for _, account := range accounts {
		preload[account.PublicKey] = account.JWT
	}

	cfg := ServerConfig{
		Port:                port,
		HTTPPort:            httpPort,
		ClusterName:         cluster.Name,
		OperatorJWT:         operator.JWT,
		SystemAccountPubKey: cluster.SystemAccountPubKey,
		ResolverPreload:     preload,
	}

	return GenerateServerConfig(cfg)
}
