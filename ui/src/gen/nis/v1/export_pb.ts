// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file nis/v1/export.proto (package nis.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * ExportOperatorRequest is the request to export an operator
 *
 * @generated from message nis.v1.ExportOperatorRequest
 */
export class ExportOperatorRequest extends Message<ExportOperatorRequest> {
  /**
   * @generated from field: string operator_id = 1;
   */
  operatorId = "";

  /**
   * Whether to include encrypted seeds
   *
   * @generated from field: bool include_secrets = 2;
   */
  includeSecrets = false;

  constructor(data?: PartialMessage<ExportOperatorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nis.v1.ExportOperatorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "include_secrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportOperatorRequest {
    return new ExportOperatorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportOperatorRequest {
    return new ExportOperatorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportOperatorRequest {
    return new ExportOperatorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExportOperatorRequest | PlainMessage<ExportOperatorRequest> | undefined, b: ExportOperatorRequest | PlainMessage<ExportOperatorRequest> | undefined): boolean {
    return proto3.util.equals(ExportOperatorRequest, a, b);
  }
}

/**
 * ExportOperatorResponse is the response containing the exported operator data
 *
 * @generated from message nis.v1.ExportOperatorResponse
 */
export class ExportOperatorResponse extends Message<ExportOperatorResponse> {
  /**
   * JSON-encoded export data
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<ExportOperatorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nis.v1.ExportOperatorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportOperatorResponse {
    return new ExportOperatorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportOperatorResponse {
    return new ExportOperatorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportOperatorResponse {
    return new ExportOperatorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExportOperatorResponse | PlainMessage<ExportOperatorResponse> | undefined, b: ExportOperatorResponse | PlainMessage<ExportOperatorResponse> | undefined): boolean {
    return proto3.util.equals(ExportOperatorResponse, a, b);
  }
}

/**
 * ImportOperatorRequest is the request to import an operator
 *
 * @generated from message nis.v1.ImportOperatorRequest
 */
export class ImportOperatorRequest extends Message<ImportOperatorRequest> {
  /**
   * JSON-encoded export data
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * Whether to regenerate UUIDs (for copying)
   *
   * @generated from field: bool regenerate_ids = 2;
   */
  regenerateIds = false;

  constructor(data?: PartialMessage<ImportOperatorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nis.v1.ImportOperatorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "regenerate_ids", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportOperatorRequest {
    return new ImportOperatorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportOperatorRequest {
    return new ImportOperatorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportOperatorRequest {
    return new ImportOperatorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportOperatorRequest | PlainMessage<ImportOperatorRequest> | undefined, b: ImportOperatorRequest | PlainMessage<ImportOperatorRequest> | undefined): boolean {
    return proto3.util.equals(ImportOperatorRequest, a, b);
  }
}

/**
 * ImportOperatorResponse is the response from importing an operator
 *
 * @generated from message nis.v1.ImportOperatorResponse
 */
export class ImportOperatorResponse extends Message<ImportOperatorResponse> {
  /**
   * ID of the imported operator
   *
   * @generated from field: string operator_id = 1;
   */
  operatorId = "";

  constructor(data?: PartialMessage<ImportOperatorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nis.v1.ImportOperatorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportOperatorResponse {
    return new ImportOperatorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportOperatorResponse {
    return new ImportOperatorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportOperatorResponse {
    return new ImportOperatorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportOperatorResponse | PlainMessage<ImportOperatorResponse> | undefined, b: ImportOperatorResponse | PlainMessage<ImportOperatorResponse> | undefined): boolean {
    return proto3.util.equals(ImportOperatorResponse, a, b);
  }
}

/**
 * ImportFromNSCRequest is the request to import an operator from NSC archive
 *
 * @generated from message nis.v1.ImportFromNSCRequest
 */
export class ImportFromNSCRequest extends Message<ImportFromNSCRequest> {
  /**
   * Compressed archive (.zip, .tar.gz, .tar.bz2) of NSC store
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * Name of the operator in NSC
   *
   * @generated from field: string operator_name = 2;
   */
  operatorName = "";

  constructor(data?: PartialMessage<ImportFromNSCRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nis.v1.ImportFromNSCRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "operator_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportFromNSCRequest {
    return new ImportFromNSCRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportFromNSCRequest {
    return new ImportFromNSCRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportFromNSCRequest {
    return new ImportFromNSCRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportFromNSCRequest | PlainMessage<ImportFromNSCRequest> | undefined, b: ImportFromNSCRequest | PlainMessage<ImportFromNSCRequest> | undefined): boolean {
    return proto3.util.equals(ImportFromNSCRequest, a, b);
  }
}

/**
 * ImportFromNSCResponse is the response from importing from NSC
 *
 * @generated from message nis.v1.ImportFromNSCResponse
 */
export class ImportFromNSCResponse extends Message<ImportFromNSCResponse> {
  /**
   * ID of the imported operator
   *
   * @generated from field: string operator_id = 1;
   */
  operatorId = "";

  constructor(data?: PartialMessage<ImportFromNSCResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nis.v1.ImportFromNSCResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportFromNSCResponse {
    return new ImportFromNSCResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportFromNSCResponse {
    return new ImportFromNSCResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportFromNSCResponse {
    return new ImportFromNSCResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportFromNSCResponse | PlainMessage<ImportFromNSCResponse> | undefined, b: ImportFromNSCResponse | PlainMessage<ImportFromNSCResponse> | undefined): boolean {
    return proto3.util.equals(ImportFromNSCResponse, a, b);
  }
}

